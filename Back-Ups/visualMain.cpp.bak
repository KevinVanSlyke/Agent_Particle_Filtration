//  Adam Sokolow
//  adam.sokolow@duke.edu
//  Dust simulation for Dr. Sen
//  Dated July 29 2005

/*	Edited by Kevin VanSlyke
kgvansly@buffalo.edu
Dated Jan 2 2016*/

#include <cmath>
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <string>
#include <iomanip>
#include <sstream>
#include <vector>
#include <math.h>
#include <errno.h>
#include <time.h>

/*	direct.h for windows filesystem manip
	unistd.h and sys/stat.h for unix filesystem manip*/
//#include <direct.h>
#include <unistd.h>
#include <sys/stat.h>
#include "timer.h"
#include <GL/glut.h>

#include "world.h"
#include "parameterReader.h"

using namespace std;

bool zoom, offvisual = false;
int myXMax, myYMax;
world * myWorld;
int viewStartX = 0;
int viewStartY = 0;
int viewEndX = 500;
int viewEndY = 500;
int timeCount = 0;
int magnification = 1;
int running = 0;
int selectX1, selectY1, selectX2, selectY2;
GLubyte * myWorldImage;

void myIdle();
void takestep();
void(*Functor)() = myIdle;
void init();
void display();
void reshape(int w, int h);
void mouse(int button, int state, int x, int y);
void setView(int Sx, int Sy, int Ex, int Ey);
void resetView();
GLubyte * updateWorldImage(int ** worldArray);
void initWorldImage();

struct Box {    /* pixel coordinates for mouse events */
	int left;
	int right;
	int top;
	int bottom;
} T_box, spin_box, button_box[3], info_box;

int isInside(struct Box *box, int x, int y) {
	return box->left < x && box->right > x
		&& box->top < y && box->bottom > y;
}

void myIdle()
{
	glutPostRedisplay();
	myWorld->updateWorld();
}

void takestep()
{
	++timeCount;
	myWorld->takeStep();
	myWorld->updateWorld();
	myWorld->writingDust(); //tracking dust particles
	if (!offvisual)
		glutPostRedisplay();
}

void init()
{
	glClearColor(1.0, 195 / 255.0, 0.0, 0.0);
	glShadeModel(GL_FLAT);
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	resetView();
}

void drawText(const string& str, int x, int y)
{
	glRasterPos2i(x, y);
	int len = str.find('\0');
	for (int i = 0; i < len; i++)
		glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, str[i]);
}

void display(void)
{
	int i;
	double w, h, dxy;
	std::string name[3] = { "Stop/Start", "Zoom In", "Turn Off Visual" };

	dxy = T_box.bottom - T_box.top;
	glClear(GL_COLOR_BUFFER_BIT);
	glColor3ub(192, 192, 192);
	//h = dxy * (myWorld->getCurDust() ) / (1000); 
	h = dxy *0.5;
	glRectf(-30.0, 0.0, -6.0, h);

	glColor3ub(0, 0, 0);
	std::ostringstream os;

	os.precision(3);
	os << myWorld->getCurDust() - 1 << std::ends;
	drawText(os.str(), -33, int(h) - 12);
	os.seekp(0);
	glColor3f(0.0, 0.0, 1.0);  /* blue */

	std::ostringstream os1;

	os1 << "Time = " << timeCount << std::ends;
	drawText(os1.str(), -33, dxy*0.5 + 250);
	os1.seekp(0);
	glColor3f(0.0, 0.0, 1.0);
	//h = dxy * (initialnumberofdust) / (2*initialnumberofdust); 
	h = dxy*0.5;
	glRectf(-33.0, h - 2, -3.0, h + 2);
	w = dxy / 3;
	for (i = 0; i < 3; i++)
	{
		if (i == 0 && !running)
		{
			glColor3ub(230, 0, 0);

			name[i] = "Paused";
		}
		else if (i == 0 && running)
		{
			glColor3ub(0, 230, 0);
			name[i] = "Running";
		}
		else if (i == 1 && zoom)
		{
			glColor3ub(230, 0, 0);
			name[i] = "Reset View";
		}
		else if (i == 1 && !zoom)
		{
			glColor3ub(0, 230, 0);
			name[i] = "Zoom In";
		}
		else if (i == 2)
		{
			if (offvisual)
			{
				glColor3ub(230, 0, 0);
				name[i] = "Turn On Visual";
			}
			else
			{
				glColor3ub(0, 230, 0);
				name[i] = "Turn Off Visual";
			}
		}
		else glColor3ub(0, 230, 0);

		glRectf(i * w + 3, -30.0, (i + 1) * w - 3, -6.0);
		glColor3ub(0, 0, 0);
		os << name[i] << std::ends;
		drawText(os.str(), i * int(w) + 10, -20);
		os.seekp(0);
	}

	glColor3ub(0, 0, 230);
	glRectf(1500, -30.0, 1500, -6.0);


	glRasterPos2i(0, 0);  //Specifies the raster position for pixel operations. 

	myWorldImage = updateWorldImage(myWorld->getWorldArray());
	glDrawPixels(myXMax, myYMax, GL_RGB, GL_UNSIGNED_BYTE, myWorldImage);

	/*  glDrawPixels: Writes a block of pixels to the frame buffer.
	myWorld->getWorldImage() =(*MyWorld).(getWorldImage)
	Means: member "getWorldImage()" of object pointed by myWorld */

	glPixelZoom(1.0, 1.0); //zooming display region, original factor=1,1 

	// a ruler 
	glColor3f(0.0, 0.0, 1.0);  /* blue */
	std::ostringstream os0;
	os0.precision(3);
	os0 << "   0" << std::ends;
	drawText(os0.str(), 500, 0);
	os0.seekp(0);

	std::ostringstream os125;
	os125.precision(3);
	os125 << " 125" << std::ends;
	drawText(os125.str(), 500, 125);
	os125.seekp(0);

	std::ostringstream os250;
	os250.precision(3);
	os250 << " 250" << std::ends;
	drawText(os250.str(), 500, 250);
	os250.seekp(0);

	std::ostringstream os375;
	os375.precision(3);
	os375 << " 375" << std::ends;
	drawText(os375.str(), 500, 375);
	os375.seekp(0);

	std::ostringstream os500;
	os500.precision(3);
	os500 << " 500" << std::ends;
	drawText(os500.str(), 500, 500);
	os500.seekp(0);
	// end ruler 
	glutSwapBuffers();         // swaps the buffers of the current window 
	glFlush();
}

void reshape(int w, int h)
{
	int min_size = 339, widget_size = 30, pad = 3;
	int i, x, y, dx, dy, dxy, widget_area_size;
	//Use to be just getMaxSize, where x and y max dimensions are equal
	int L = myWorld->getMaxXSize();
	widget_area_size = L > 300 ? L : 300;
	dx = dy = pad + widget_size + pad + L + pad;
	if (dx < min_size)
		dx = min_size;
	if (dy < min_size)
		dy = min_size;

	/*
	If you wanted to center the dust image... but we dont.
		 x = w > dx ? (w - dx) / 2 : 0;
		 y = h > dy ? (h - dy) / 2 : 0;
	*/

	x = 15;
	y = 35;

	glViewport((GLint)x, (GLint)y, (GLsizei)dx, (GLsizei)dy);

	T_box.left = x + pad;
	T_box.right = T_box.left + widget_size;
	T_box.bottom = h - y - pad - widget_size - pad;
	T_box.top = T_box.bottom - widget_area_size;

	spin_box.left = x + pad + widget_size + pad;
	spin_box.right = spin_box.left + L;
	spin_box.bottom = T_box.bottom;
	spin_box.top = spin_box.bottom - L;

	info_box.left = spin_box.right + pad + widget_size;
	info_box.right = info_box.left + 200;
	info_box.top = spin_box.bottom - L;
	info_box.bottom = T_box.bottom;

	dxy = widget_area_size / 3;

	for (i = 0; i < 3; i++)
	{
		button_box[i].left = spin_box.left + i * dxy + pad;
		button_box[i].right = spin_box.left + (i + 1) * dxy - pad;
		button_box[i].top = spin_box.bottom + pad;
		button_box[i].bottom = button_box[i].top + widget_size;
	}

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	x = y = -pad - widget_size - pad;
	glOrtho(x, x + dx, y, y + dy, -1.0, 1.0);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
}

void mouse(int button, int state, int x, int y)
{
	switch (button) {
	case GLUT_LEFT_BUTTON:
		if (state == GLUT_DOWN) {
			if (isInside(&T_box, x, y))
			{
				//				   outfilebit(); 
			}
			else if (isInside(&button_box[0], x, y))
			{
				if (running) {
					running = 0;
					glutIdleFunc(myIdle);
				}
				else {
					running = 1;
					glutIdleFunc(takestep);
				}
			}
			else if (isInside(&button_box[1], x, y))
			{
				if (zoom)
				{
					zoom = false;
					resetView();
				}
				else
					zoom = true;
			}
			else if (isInside(&spin_box, x, y))
			{
				selectX1 = x - spin_box.left;
				selectY1 = spin_box.top - y;
			}
			else if (isInside(&button_box[2], x, y))
			{
				offvisual ? offvisual = false : offvisual = true;
			}
		}
		if (state == GLUT_UP && isInside(&spin_box, x, y) && zoom)
		{
			selectX2 = x - spin_box.left;
			selectY2 = spin_box.top - y;
			if (selectX1 != selectX2&&selectY1 != selectY2)
			{
				setView(selectX1, selectY2, selectX2, selectY1);
				magnification = (max(min(500 / ((selectX2 - selectX1)), 500 / ((selectY1 - selectY2))), 1));
			}

		}
		glutPostRedisplay();
		break;
	default:
		break;
	}
}

GLubyte * updateWorldImage(int ** worldArray)   // GLubyte * <declare "getWorldImage()" member> 
{
	GLubyte * worldImage = myWorldImage;
	if (viewStartX < viewEndX && viewStartY < viewEndY)
	{

		for (int c = 0; c < myXMax; c++)
		{
			for (int d = 0; d < myYMax; d++)
			{
				worldImage[3 * (myXMax * (c)+d) + 0] = (GLubyte)0;
				worldImage[3 * (myXMax * (c)+d) + 1] = (GLubyte)0;
				worldImage[3 * (myXMax * (c)+d) + 2] = (GLubyte)0;
			}
		}
		for (int c = viewStartX; c < viewEndX; c++) 
		{
			for (int d = viewStartY; d < viewEndY; d++) 
			{
				for (int m1 = 0; m1 < magnification; ++m1)
				{
					for (int m2 = 0; m2 < magnification; ++m2)
					{
						worldImage[3 * (myXMax * (magnification*(c - viewStartX) + m1) + magnification*(d - viewStartY) + m2) + 0] = (GLubyte)(worldArray[c][d] >= 0 ? (int)(1 * ((worldArray[c][d] + 2)*(worldArray[c][d] + 2)*(worldArray[c][d] + 2))) % 255 : 255);
						worldImage[3 * (myXMax * (magnification*(c - viewStartX) + m1) + magnification*(d - viewStartY) + m2) + 1] = (GLubyte)(worldArray[c][d] >= 0 ? (int)(100 * (worldArray[c][d] + 1) % 255) : 255);
						worldImage[3 * (myXMax * (magnification*(c - viewStartX) + m1) + magnification*(d - viewStartY) + m2) + 2] = (GLubyte)(worldArray[c][d] >= 0 ? (int)(200 * ((worldArray[c][d] + 2)*(worldArray[c][d] + 2))) % 255 : 255);
					}
				}
			}
		}
	}
	return worldImage;

}

void setView(int Sx, int Sy, int Ex, int Ey)
{
	viewStartX = Sx;
	viewStartY = Sy;
	viewEndX = Ex;
	viewEndY = Ey;
}

void resetView()
{
	viewStartX = 0;
	viewStartY = 0;
	viewEndX = myXMax;
	viewEndY = myYMax;
	magnification = 1;
}

void initWorldImage()
{
	myWorldImage = new GLubyte[myXMax * myYMax * 3];
}

// *******
// M A I N
// *******
int main(int argc, char *argv[])
{
	int trialID;
//	struct timespec before, after;
//	struct timespec time_diff;
//	double time_s;
//	get_time(&before);


	/////////////////////
	/* Parameters so far:

	World Dimensions: X, Y
	World Speeds: x, y

	Total Dust: n
	Size Range of Dust: 1 -> N

	Total timesteps: t
	Enable: merging, splitting, sticking
	Filter Parameters: Length, Width of Slits, Width of Gaps
	trialID
	*/
	int filter, xMax, yMax, xSpeed, ySpeed, totalGrains, MinGrainSize, MaxGrainSize, MaxTime, sticking, splitting, merging, FilterWidth, FilterGap, FilterLength, Filter2Width, Filter2Gap, Filter2Length;
	bool enableSticking, enableSplitting, enableMerging;
	if (argc < 12)
	{
		std::cout << "Not enough parameters passed to main (Need 11, 14 or 17 integers after the executable name), trying to read from parameters.txt... " << std::endl;
		parameterReader *pR = new parameterReader();
		xMax = pR->getxMax();
		yMax = pR->getyMax();
		xSpeed = pR->getxSpeed();
		ySpeed = pR->getySpeed();
		totalGrains = pR->gettotalGrains();
		MaxTime = pR->getMaxTime();
		enableSticking = pR->getSticking();
		enableSplitting = pR->getSplitting();
		enableMerging = pR->getMerging();
		MinGrainSize = pR->getMinGrainSize();
		MaxGrainSize = pR->getMaxGrainSize();
		FilterWidth = pR->getFilterWidth();
		FilterGap = pR->getFilterGap();
		FilterLength = pR->getFilterLength();
		Filter2Width = pR->getFilter2Width();
		Filter2Gap = pR->getFilter2Gap();
		Filter2Length = pR->getFilter2Length();
		trialID = pR->getTrialID();
	}
	else if(argc == 13)
	{
		xMax = atof(argv[1]);
		yMax = atof(argv[2]);
		xSpeed = atof(argv[3]);
		ySpeed = atof(argv[4]);
		totalGrains = atof(argv[5]);
		MinGrainSize = atof(argv[6]);
		MaxGrainSize = atof(argv[7]);
		MaxTime = atof(argv[8]);
		sticking = atof(argv[9]);
		if (sticking == 1)
			enableSticking = true;
		else
			enableSticking = false;
		splitting = atof(argv[10]);
		if (splitting == 1)
			enableSplitting = true;
		else
			enableSplitting = false;
		merging = atof(argv[11]);
		if (merging == 1)
			enableMerging = true;
		else
			enableMerging = false;
		trialID = atof(argv[12]);
		FilterWidth = -1;
		FilterGap = -1;
		FilterLength = -1;
		Filter2Width = -1;
		Filter2Gap = -1;
		Filter2Length = -1;
		filter = 0;
	}
	else if(argc == 16)
	{
		xMax = atof(argv[1]);
		yMax = atof(argv[2]);
		xSpeed = atof(argv[3]);
		ySpeed = atof(argv[4]);
		totalGrains = atof(argv[5]);
		MinGrainSize = atof(argv[6]);
		MaxGrainSize = atof(argv[7]);
		MaxTime = atof(argv[8]);
		sticking = atof(argv[9]);
		if (sticking == 1)
			enableSticking = true;
		else
			enableSticking = false;
		splitting = atof(argv[10]);
		if (splitting == 1)
			enableSplitting = true;
		else
			enableSplitting = false;
		merging = atof(argv[11]);
		if (merging == 1)
			enableMerging = true;
		else
			enableMerging = false;
		FilterWidth = atof(argv[12]);
		FilterGap = atof(argv[13]);
		FilterLength = atof(argv[14]);
		trialID = atof(argv[15]);
		Filter2Width = -1;
		Filter2Gap = -1;
		Filter2Length = -1;
		filter = 1;
	}
	else if(argc == 19)
	{
		xMax = atof(argv[1]);
		yMax = atof(argv[2]);
		xSpeed = atof(argv[3]);
		ySpeed = atof(argv[4]);
		totalGrains = atof(argv[5]);
		MinGrainSize = atof(argv[6]);
		MaxGrainSize = atof(argv[7]);
		MaxTime = atof(argv[8]);
		sticking = atof(argv[9]);
		if (sticking == 1)
			enableSticking = true;
		else
			enableSticking = false;
		splitting = atof(argv[10]);
		if (splitting == 1)
			enableSplitting = true;
		else
			enableSplitting = false;
		merging = atof(argv[11]);
		if (merging == 1)
			enableMerging = true;
		else
			enableMerging = false;
		FilterWidth = atof(argv[12]);
		FilterGap = atof(argv[13]);
		FilterLength = atof(argv[14]);
		Filter2Width = atof(argv[15]);
		Filter2Gap = atof(argv[16]);
		Filter2Length = atof(argv[17]);
		trialID = atof(argv[18]);
		filter = 2;
	}
	myXMax = xMax;
	myYMax = yMax;
	
	glutInit(&argc, argv);
	initWorldImage();
	
	myWorld = new world(xMax, yMax, xSpeed, ySpeed);
	/*Sets the simulation size in the dust_list object for use in dust_list routines*/
	myWorld->myList->setMaxXLoc(xMax);
	myWorld->myList->setMaxYLoc(yMax);
	//TODO: Make arbitrary for any number of filter lines appended to end of parameter text file.
	if (FilterGap == (-1) && Filter2Gap == (-1))
	{
		filter = 0;
		myWorld->populateWorld(totalGrains, MinGrainSize, MaxGrainSize);
		std::cout << "No Filter detected." << std::endl;
	}
	else if (FilterGap != (-1) && Filter2Gap == (-1))
	{
		filter = 1;
		myWorld->populateWorld(totalGrains, MinGrainSize, MaxGrainSize, FilterGap, FilterWidth, FilterLength);
		std::cout << "Filter gap: " << FilterGap << std::endl;
	}
	else if (FilterGap != (-1) && Filter2Gap != (-1))
	{
		filter = 2;
		myWorld->populateWorld(totalGrains, MinGrainSize, MaxGrainSize, FilterGap, FilterWidth, FilterLength, Filter2Gap, Filter2Width, Filter2Length);
		std::cout << "Filter 1 gap: " << FilterGap << std::endl;
		std::cout << "Filter 2 gap: " << Filter2Gap << std::endl;
	}

	/*  Routine for creating folder, need to make alternate version for Linux file systems*/

	std::cout << "Total No. of Dust Grains =  " << myWorld->myList->getTotal() - filter << std::endl;
	std::cout << "X Max = " << myWorld->getMaxXSize() << ". Y Max = " << myWorld->getMaxYSize() << ". " << std::endl;
	//"/gpfs/scratch/kgvansly/"
	//"/projects/academic/sen/kgvansly/Dust_Data"
	//"/home/kevin/Dust_Data"
	std::ostringstream oFolder;
	oFolder << filter << "fltrs" << FilterGap << "pr" << FilterWidth << "fbr" << FilterLength << "fl"<< totalGrains << "ptcls" << MinGrainSize << "-" << MaxGrainSize << "dstr" << xMax << "x" << yMax << "y" << xSpeed << "vx" << ySpeed << "vy" << MaxTime << "tm";
	std::string outputFolder = oFolder.str();

	if(mkdir(outputFolder.c_str(), S_IRWXU) == -1)
		std::cout << "Folder " << outputFolder << " already exists, entering..." << std::endl;
	else
		mkdir(outputFolder.c_str(), S_IRWXU);
	chdir(outputFolder.c_str());

	struct stat fileInfo;
	if (stat("parameters.txt", &fileInfo) == 0)
	{
		std::cout << "parameters.txt already exists, not writting" << std::endl;
	}
	else
	{
		FILE * parameterFile = fopen("parameters.txt", "a");
		// OUTPUT: dust, size, y-position, y-step, x-localSp, y-localSp
		fprintf(parameterFile, "%d %d \n%d %d \n%d \n%d %d \n%d \n%d %d %d \n%d %d %d \n%d %d %d", xMax, yMax, xSpeed, ySpeed, totalGrains, MinGrainSize, MaxGrainSize, MaxTime, sticking, splitting, merging, FilterWidth, FilterGap, FilterLength, Filter2Width, Filter2Gap, Filter2Length);
		fclose(parameterFile);
	}

	std::ostringstream pFolder;
	pFolder << "Trial" << trialID;
	std::string processFolder = pFolder.str();
	mkdir(processFolder.c_str(), S_IRWXU);
	chdir(processFolder.c_str());
	/* End of folder creation routine */

	/* Statistics collection calls, might be better to move them to lower level objects. */
	myWorld->myList->dust_dstr();
	myWorld->myList->setFunctionality(enableSplitting, enableSticking, enableMerging);
	//Debug line
	//std::cout << "Dust distribution has been calculated." << std::endl;
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);
	glutInitWindowSize(myXMax + 200 + 39, myYMax + 150 + 39);
	glutInitWindowPosition(10, 10);

	glutCreateWindow("Dust Simulation");

	std::cout << "Drawing Window" << std::endl;

	init();
	glutDisplayFunc(display);

	glutReshapeFunc(reshape);
	glutMouseFunc(mouse);
	glutIdleFunc(myIdle);
	glutMainLoop();
	/* Runs program for determined amount of time. */

/*	get_time(&after);
	diff(&before, &after, &time_diff);
	time_s = time_diff.tv_sec + (double)(time_diff.tv_nsec)/1.0e9;
	std::cout << "Total runtime is: " << time_s << " seconds." << std::endl;

	ofstream timeOptimization("timeOptimization.txt", ios::app);
	if (timeOptimization.is_open())
	{
		//writing: time of calculation, number of particles and length/width
		timeOptimization << "Total runtime is: " << time_s << " seconds." << std::endl;
		timeOptimization << "For " << MaxTime << "timesteps." << std::endl;
		timeOptimization << "Simulation of " << totalGrains << " particles in an area of:" << std::endl;
		timeOptimization << xMax << " by " << yMax << ". (x by y)" << std::endl;
		timeOptimization.close();
	}

	std::cout << "Simulation completed!" << std::endl;
	return 0;
*/
}
